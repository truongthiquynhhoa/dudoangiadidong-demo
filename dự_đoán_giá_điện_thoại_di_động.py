# -*- coding: utf-8 -*-
"""Dự đoán giá điện thoại di động.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TijGhzKSIyAY1ZKmYFiU9Azrm-AG_Oio
"""

# Import thư viện 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import tree
# Pandas_Profiloing: Công cụ hỗ trợ giảm thời gian EDA 
from pandas_profiling import ProfileReport

# Train Test Split: Kĩ thuật đánh giá hiệu suất của thuật toán học máy
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier 
from sklearn import svm
from sklearn.svm import SVC
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn import metrics
from sklearn.metrics import confusion_matrix, auc, roc_curve
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import PrecisionRecallDisplay, RocCurveDisplay
from sklearn.metrics import ConfusionMatrixDisplay, classification_report
from statistics import stdev
from sklearn.ensemble import VotingClassifier
import warnings
warnings.filterwarnings('ignore')

# Bảng màu và chủ đề
import matplotlib.colors

colors = ["Green","Blue","Orange",'Black','Red','Pink']
colors2 = ["#2e5551",'#468e71','#4d9b68','#59ae8c', "#e9f5f0","#d5eae9"]
cmap = matplotlib.colors.ListedColormap(colors2)

sns.palplot(sns.color_palette(colors))

from google.colab import files
uploaded = files.upload()

test = pd.read_csv('test.csv')

Data = pd.read_csv('train.csv')

# Xem trước 5 dòng dữ liệu (data)
Df = pd.DataFrame(Data)
Df.head(5)

# Xem trước 5 dòng dữ liệu (test)
Df_test = pd.DataFrame(test)
Df_test.head(5)

# Xem kích thước của tập dữ liệu
rows, col = Df.shape
print ("Dimensions of dataset: {}" . format (Df.shape))
print ('Rows:', rows, '\nColumns:', col)

# Chi tiết thống kê
Df.iloc[:, :-1].describe().T.sort_values(by='std', ascending = False)\
                          .style.background_gradient(cmap="Greens")\
                          .bar(subset=["max"], color='#F8766D')\
                          .bar(subset=["mean"], color='#00BFC4')

# Số phần tử duy nhất trong mỗi cột
unique = Df.nunique()
unique.to_frame().T

# Thông tin về khung dữ liệu
Df.info()

# Xem kích thước của tập dữ liệu 
rows, col = Df_test.shape
print ("Dimensions of dataset: {}" . format (Df_test.shape))
print ('Rows:', rows,'\nColumns:', col)

# Chi tiết thống kê
Df_test.iloc[:, :-1].describe().T.sort_values(by='std' , ascending = False)\
                     .style.background_gradient(cmap='Greens')\
                     .bar(subset=["max"], color='#F8766D')\
                     .bar(subset=["mean",], color='#00BFC4')

# Thông tin về khung dữ liệu
Df_test.info()

Df.m_dep.describe()



Df.px_height.describe()

Df.sc_w.describe()

# Tìm các giá trị dưới 0,5 cm
below_threshold = Df["m_dep"][Df["m_dep"] < 0.5]

# Đếm số lượng giá trị dưới 0,5 cm
num_below_threshold = len(below_threshold)

# In số lượng giá trị dưới 0,5 cm
print("Số lượng giá trị dưới 0,5 cm trong tính năng 'm_dep':", num_below_threshold)

# Thay thế các giá trị dưới 0,5 cm bằng 0,5 cm
Df["m_dep"][Df["m_dep"] < 0.5] = 0.5

Df.m_dep.describe()

# Tìm các giá trị dưới 0,5 cm
below_threshold3 = Df_test["m_dep"][Df_test["m_dep"] < 0.5]

# Đếm số lượng giá trị dưới 0,5 cm
num_below_threshold3 = len(below_threshold3)

# In số lượng giá trị dưới 0,5 cm
print("Number of values below 0.5 cm in 'm_dep' feature: ", num_below_threshold3)

# Thay thế các giá trị dưới 0,5 cm bằng 0,5 cm
Df_test["m_dep"][Df_test["m_dep"] < 0.5] = 0.5

Df_test.m_dep.describe()

# Tìm các giá trị dưới 65 pixel
below_threshold1 = Df["px_height"][Df["px_height"] < 65]

# Đếm số lượng giá trị dưới 65 pixel
num_below_threshold1 = len(below_threshold1)

# In số lượng giá trị dưới 65 pixel
print("Số giá trị dưới 65 pixel trong tính năng 'px_height': ", num_below_threshold1)

# Thay thế các giá trị dưới 65 pixel bằng 65 pixel
Df["px_height"][Df["px_height"] < 65] = 65

Df.px_height.describe()

# Tìm các giá trị dưới 65 pixel
below_threshold4 = Df_test["px_height"][Df_test["px_height"] < 65]

# Đếm số lượng giá trị dưới 65 pixel
num_below_threshold4 = len(below_threshold4)

# In số lượng giá trị dưới 65 pixel
print("Số giá trị dưới 65 pixel trong tính năng 'px_height': ", num_below_threshold4)

# Thay thế các giá trị dưới 65 pixel bằng 65 pixel
Df_test["px_height"][Df_test["px_height"] < 65] = 65

Df_test.px_height.describe()

# Tìm các giá trị dưới 2,54 cm
below_threshold2 = Df["sc_w"][Df["sc_w"] < 2.54]

# Đếm số lượng giá trị dưới 2,54 cm
num_below_threshold2 = len(below_threshold2)

# In số lượng giá trị dưới 2,54 cm
print("Số lượng giá trị dưới 2,54 cm trong tính năng 'sc_w': ", num_below_threshold2)

# Thay thế các giá trị dưới 2,54 cm bằng 2,54 cm
Df["sc_w"][Df["sc_w"] < 2.54] = 2.54

Df.sc_w.describe()

# Tìm các giá trị dưới 2,54 cm
below_threshold5 = Df_test["sc_w"][Df_test["sc_w"] < 2.54]

# Đếm số lượng giá trị dưới 2,54 cm
num_below_threshold5 = len(below_threshold5)

# In số lượng giá trị dưới 2,54 cm
print("Số lượng giá trị dưới 2,54 cm trong tính năng 'sc_w': ", num_below_threshold5)

# Thay thế các giá trị dưới 2,54 cm bằng 2,54 cm
Df_test["sc_w"][Df_test["sc_w"] < 2.54] = 2.54

Df_test.sc_w.describe()

# Thiếu giá trị (train)
plt.figure(figsize=(22,4))
sns.heatmap((Df.isna().sum()).to_frame(name='').T,cmap='GnBu', annot=True,
             fmt='0.0f').set_title('Đếm các giá trị còn thiếu (train data)', fontsize=18)
plt.show()

# Thiếu giá trị (test)
plt.figure(figsize=(22,4))
sns.heatmap((Df_test.isna().sum()).to_frame(name='').T,cmap='GnBu', annot=True,
             fmt='0.0f').set_title('Đếm các giá trị còn thiếu (test data)', fontsize=18)
plt.show()

# Xóa cộ Id trong test data
Df_test.drop(['id'], axis=1, inplace=True)
Df_test.shape

# Các tính năng số và phân loại riêng biệt
num_cols = pd.DataFrame (Df, columns= ['battery_power', 'clock_speed', 'fc', 'int_memory', 'm_dep', 'mobile_wt', 'pc', 'px_height', 'px_width', 'ram', 'sc_h', 'sc_w', 'talk_time'])
cat_cols = pd.DataFrame (Df, columns= ['blue', 'dual_sim', 'four_g', 'n_cores', 'three_g', 'touch_screen', 'wifi'])

# Tách các tính năng số và phân loại thành các danh sách khác nhau
numerical_columns = list(Df.loc[:,['battery_power', 'clock_speed', 'fc', 'int_memory', 'm_dep', 'mobile_wt', 'pc', 'px_height', 'px_width', 'ram', 'sc_h', 'sc_w', 'talk_time']])
categorical_columns = list(Df.loc[:,['blue', 'dual_sim', 'four_g', 'n_cores', 'three_g', 'touch_screen', 'wifi']])

# Trực quan hóa các tính năng số bằng boxplots
sns.set_style('darkgrid')
def boxplots_custom(dataset, columns_list, rows, cols, suptitle):
    fig, axs = plt.subplots(rows, cols, sharey=True, figsize=(15,7))
    fig.suptitle(suptitle, y=1, size=25)
    axs = axs.flatten()
    for i, data in enumerate(columns_list):
        sns.boxplot(data=dataset[data], orient='h', color ='green', ax=axs[i])
        axs[i].set_title(data + ', skewness is: '+str(round(dataset[data].skew(axis = 0, skipna = True), 2)))
        
boxplots_custom(dataset=Df, columns_list=num_cols, rows=5, cols=3, suptitle='Boxplots for each variable')
plt.tight_layout()

# Tính toán IQR cho từng cột trong tập dữ liệu
Q1 = num_cols.quantile(0.25)
Q3 = num_cols.quantile(0.75)
IQR = Q3 - Q1

# Xác định các ngoại lệ bằng phương pháp IQR
outliers = ((num_cols < (Q1 - 1.5 * IQR)) | (num_cols > (Q3 + 1.5 * IQR)))

# Đếm số lượng ngoại lệ cho mỗi biến
num_outliers = outliers.sum()

# Số ngoại lệ cho mỗi biến
num_outliers.to_frame().T

# Kiểm tra noises bằng pairplot
sns.set_palette('crest')
sns.set_style('darkgrid')
dnp = sns.pairplot(Df.loc[:, numerical_columns])

# Thêm axis labels và tick labels vào biểu đồ
dnp.set(xticklabels=[], yticklabels=[])
dnp.axes[0][0].set_ylabel(numerical_columns[0], fontsize=14)
dnp.axes[-1][0].set_xlabel(numerical_columns[0], fontsize=14)
dnp.axes[-1][0].xaxis.labelpad = 20
dnp.axes[-1][-1].yaxis.labelpad = 20

# Tên của buổi đồ
dnp.fig.suptitle('Ghép nối cho từng biến\n(Range: min={}, max={})'.format(Df[numerical_columns].min().min(), Df[numerical_columns].max().max()), y=1.03, fontsize=25)

# Hiển thị biểu đồ
plt.show()

TARGET = 'price_range'
FEATURES = [col for col in Df.columns if col not in ['Df', TARGET]]

cat_features = [col for col in FEATURES if Df[col].nunique() < 25]
cont_features = [col for col in FEATURES if Df[col].nunique() >= 25]

num_cat_features = len(cat_features)
num_cont_features = len(cont_features)

print(f"Tổng số tính năng ngoại trừ mục tiêu: {len(FEATURES)}")
print(f"\033[92mNumber of categorical (<25 Unique Values) features: {num_cat_features}")
print(f"\033[96mNumber of continuous features: {num_cont_features}")

# Xác định nhãn và màu sắc cho biểu đồ hình tròn
labels = ['Categorical (<25 Unique Values)', 'Continuous']
colors = ['#bbddcb', '#cdddbb']

plt.pie([num_cat_features, num_cont_features], 
        labels=labels,
        colors=colors,
        textprops={'fontsize': 13},
        autopct='%1.1f%%')

# Thêm tên biểu đồ
plt.title('Phân phối các tính năng phân loại và liên tục', fontsize=16)

# Hiển thị biểu đồ
plt.show()

# Đếm số lần xuất hiện của từng giá trị trong cột 'price_range'
value_counts = Df['price_range'].value_counts()

# Xác định các chuỗi nhãn bằng f-strings
label = [f'{"Very high" if i==0 else "High" if i==1 else "Medium" if i==2 else "Low"} cost' for i in range(len(value_counts))]

# Xác định màu sắc cho từng phần
colors = ["Green","Blue","Orange",'Black']

# Tạo biểu đồ hình tròn với các giá trị phần trăm được định dạng bằng dấu % và phá vỡ các phần
fig, ax = plt.subplots()
wedges, texts, autotexts = ax.pie(value_counts.values, autopct='%0.1f%%', explode=[0.1, 0.1, 0.1, 0.1], shadow=True, labels=label, colors=colors)

# Thêm số lượng theo tỷ lệ phần trăm
for i, autotext in enumerate(autotexts):
    count = value_counts[i]
    autotext.set_text(f'{autotext.get_text()} ({count})')
    autotext.set_y(autotext.get_position()[1]-0.1)

# Đặt tiêu đề cho biểu đồ hình tròn
ax.set_title('Cân bằng hay Mất cân bằng?')

# Hiển thị biểu đồ hình tròn
plt.show()

from IPython.core.display import HTML

def multi_table(table_list):
    ''' Acceps a list of IpyTable objects and returns a table which contains each IpyTable in a cell
    '''
    return HTML(
        '<table><tr style="background-color:pink;">' + 
        ''.join(['<td>' + table._repr_html_() + '</td>' for table in table_list]) +
        '</tr></table>')

fig, axes = plt.subplots(7,2, figsize=(40,70))
sns.set_style('darkgrid')
idx = 0
for col in categorical_columns:
    sns.countplot(data=Df, y=col, palette='Greens', orient='h',
                  ax=axes[idx][0]).set_title(f'Count of {col}', fontsize='16')
    for container in axes[idx][0].containers:
        axes[idx][0].bar_label(container)
    sns.countplot(data=Df, y=col, palette='mako', orient='h',  hue='price_range',
                  ax=axes[idx][1]).set_title(f'Count of {col} per Price range', fontsize='16')
    for container in axes[idx][1].containers:
        axes[idx][1].bar_label(container)
    idx +=1
plt.show()

print("Tổng quan về tỷ lệ phần trăm của từng giá trị duy nhất trong các tính năng phân loại khác nhau:")
Df_nunique = {var: pd.DataFrame((Df[var].value_counts()/len(Df[var])*100).map('{:.2f}%'.format)) 
              for var in {'blue', 'dual_sim', 'four_g', 'n_cores', 'three_g', 'touch_screen', 'wifi'}}
multi_table([Df_nunique['blue'], Df_nunique['dual_sim'],Df_nunique['four_g'],Df_nunique['n_cores'],Df_nunique['three_g'],Df_nunique['touch_screen'],Df_nunique['wifi']])

# Mô tả các biến phân loại
cat_cols.describe().style.background_gradient(cmap='Oranges')

fig, axes = plt.subplots(13,2, figsize=(15,80))
sns.set_style('darkgrid')
idx = 0
for col in (numerical_columns):
    sns.kdeplot(data=Df, x=col, palette='Greens',fill=True , hue='price_range', 
                ax=axes[idx][0]).set_title(f'Distribution of {col}', fontsize='16')
    sns.boxplot(data=Df, x=col, palette='light:#5A9' , y='price_range', orient='h', 
                ax=axes[idx][1]).set_title(f'BoxPlot of {col}', fontsize='16')
    idx +=1
plt.show()

pr = Df.groupby(['price_range'])
target = pr.describe(percentiles = [0.25, 0.5, 0.75])[numerical_columns]
target.style.background_gradient(cmap='Reds')

Df.clock_speed.describe()

# clock_speed dựa theo price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['clock_speed'], hue ="price_range", data=Df) 
plt.show()

Df.fc.describe()

# fc dựa theo price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['fc'], hue ="price_range", data=Df) 
plt.show()

Df.int_memory.describe()

# số lượng int_memory
plt.figure(figsize = (13,6))
sns.countplot(x = Df['int_memory'], palette='dark:#5A9_r', data=Df) 
plt.show()

Df.m_dep.describe()

# m_dep dựa vào price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['m_dep'], hue ="price_range", data=Df) 
plt.show()

Df.pc.describe()

# pc dựa vào price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['pc'], hue ="price_range", data=Df) 
plt.show()

Df.sc_h.describe()

# sc_h dựa vào price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['sc_h'], hue ="price_range", data=Df) 
plt.show()

Df.sc_w.describe()

# sc_w dựa vào price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['sc_w'], hue ="price_range", data=Df) 
plt.show()

Df.talk_time.describe()

# talk_time dựa vào price_range
plt.figure(figsize = (13,6))
sns.countplot(x = Df['talk_time'], hue ="price_range", data=Df) 
plt.show()

# Tạo biểu đồ phân tán
sns.relplot(data=Df, x="ram", y="price_range", hue="price_range", palette="ch:r=-.5, l=.75")

# Thêm nhãn trục
plt.xlabel("RAM", fontsize=10)
plt.ylabel("Price Range", fontsize=10)

# Hiển thị biểu đồ
plt.show()

f,ax=plt.subplots(1,2,figsize=(13, 3))

ax1= Df[['price_range','blue']].groupby(['blue']).mean().plot.bar(color='#9bbf8a',ax=ax[0])
for container in ax1.containers:
    ax1.bar_label(container)
ax[0].set_title('Giá trị trung bình Price range của mỗi Bluetooth (0: No, 1: Yes)')
ax1.legend().set_visible(False)

ax2= Df[['price_range','dual_sim']].groupby(['dual_sim']).mean().plot.bar(color='#99b49a',ax=ax[1])  
for container in ax2.containers:
    ax2.bar_label(container)
ax[1].set_title('Giá trị trung bình Price range của mỗi Dual SIM (0: No, 1: Yes)')
ax2.legend().set_visible(False)

plt.show()

f,ax=plt.subplots(1,2,figsize=(16, 3))

ax1= Df[['price_range','four_g']].groupby(['four_g']).mean().plot.bar(color='#869d84',ax=ax[0])
for container in ax1.containers:
    ax1.bar_label(container)
ax[0].set_title('Giá trị trung bình Price range của mỗi 4G (0: No, 1: Yes)')
ax1.legend().set_visible(False)

ax2= Df[['price_range','n_cores']].groupby(['n_cores']).mean().plot.bar(color='#8d9d9b',ax=ax[1])  
for container in ax2.containers:
    ax2.bar_label(container)
ax[1].set_title('Giá trị trung bình Price range của mỗi Number of cores')
ax2.legend().set_visible(False)

plt.show()

f,ax=plt.subplots(1,2,figsize=(15, 3))

ax1= Df[['price_range','three_g']].groupby(['three_g']).mean().plot.bar(color='#58a29d',ax=ax[0])
for container in ax1.containers:
    ax1.bar_label(container)
ax[0].set_title('Giá trị trung bình Price range của mỗi 3G (0: No, 1: Yes)')
ax1.legend().set_visible(False)

ax2= Df[['price_range','touch_screen']].groupby(['touch_screen']).mean().plot.bar(color='#849d9b',ax=ax[1])  
for container in ax2.containers:
    ax2.bar_label(container)
ax[1].set_title('Giá trị trung bình Price range của mỗi Touch Screen (0: No, 1: Yes)')
ax2.legend().set_visible(False)

plt.show()

plt.figure(figsize = (12, 3))
a=Df.groupby('wifi')['price_range'].mean()
ax = a.plot.bar(color="#254441", width=.5)
for container in ax.containers:
    ax.bar_label(container)
plt.title('Giá trị trung bình Price range của mỗi Wifi (0: No, 1: Yes)', size=10)
plt.ylabel('Price range', size=11)
plt.xlabel('Wifi', size=11)
plt.xticks(rotation=0)
plt.legend().set_visible(False)
plt.show()

# Mô tả các biến số
num_cols.describe().style.background_gradient(cmap='Reds')

g = sns.FacetGrid(Df, col="price_range", hue="price_range")
g.map(sns.scatterplot, "int_memory", "ram")
g.set_axis_labels("Internal Memory (GB)", "Ram (MB)")
plt.show()

sns.relplot(data=Df, x="ram", y="battery_power", hue="price_range", palette="ch:r=-.5,l=.75")
plt.xlabel('Ram')
plt.ylabel('Battery Power')
plt.title('Ram & Battery power')
plt.show()

sns.relplot(data=Df, x="px_width", y="px_height", hue="price_range", palette="ch:r=-.5,l=.75")
plt.xlabel('Pixel Width')
plt.ylabel('Pixel Height')
plt.show()

sns.relplot(data=Df, x="sc_w", y="sc_h", hue="price_range", palette="ch:r=-.5,l=.75")
plt.xlabel('Screen Width')
plt.ylabel('Screen Height')
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='blue', orient='h', ax=axes[0])
axes[0].set_title('Bluetooth - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='blue', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='dual_sim', orient='h', ax=axes[0])
axes[0].set_title('Dual Sim - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='dual_sim', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='four_g', orient='h', ax=axes[0])
axes[0].set_title('4G - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='four_g', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='n_cores', orient='h', ax=axes[0])
axes[0].set_title('Number of Cores - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='n_cores', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='three_g', orient='h', ax=axes[0])
axes[0].set_title('3G - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='three_g', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='touch_screen', orient='h', ax=axes[0])
axes[0].set_title('Touch Screen - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='touch_screen', orient='h', ax=axes[1])
plt.show()

fig, axes = plt.subplots(2,1, figsize=(12,6))
sns.stripplot(data=Df, x='ram', palette='viridis', hue='price_range', y='wifi', orient='h', ax=axes[0])
axes[0].set_title('Wifi - Ram', fontsize='16')
axes[0].legend(loc=4)
sns.boxplot(data=Df, x='ram', palette='viridis', hue='price_range', y='wifi', orient='h', ax=axes[1])
plt.show()

plt.figure (figsize = (12, 7), dpi = 100)
heatmap = sns.heatmap (Df.corr()[['price_range']].sort_values (by = 'price_range', ascending = False), vmin = -1, vmax = 1, annot = True, cmap = 'GnBu')
heatmap.set_title ('Tính năng tương quan với Price Range', fontdict = {'fontsize':12}, pad = 18);

fig=plt.gcf()
fig.set_size_inches(16, 10)
plt.title('Mối tương quan giữa các tính năng')
a = sns.heatmap(Df.corr(), annot = True, cmap = 'GnBu', fmt='.2f', linewidths=0.2)
a.set_xticklabels(a.get_xticklabels(), rotation=90)
a.set_yticklabels(a.get_yticklabels(), rotation=30)
plt.show()

df = Df
X = df.drop('price_range', axis=1)
y = df['price_range'].values.reshape(-1, 1)

# Mảng giá trị kích thước thử nghiệm từ 0,2 đến 0,3
test_size = np.arange(start=0.2, stop=0.35, step= 0.05)

# Khởi tạo danh sách nơi chúng tôi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score =[]
for size in test_size:
    X_train1, X_test1, y_train1, y_test1 = train_test_split (X, y, test_size=size, random_state=0)
    DT_Clf = DecisionTreeClassifier (max_depth=3)
    DT_Clf.fit (X_train1, y_train1)
    score.append (DT_Clf.score (X_test1, y_test1))
# Tạo một khung dữ liệu để hiển thị kết quả
r= pd.DataFrame({'Test size': test_size , 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='#acd9a8')

# Tách X và y thành các tập huấn luyện và kiểm tra
X_train1, X_test1, y_train1, y_test1 = train_test_split (X, y, stratify=y, test_size = 0.3, random_state = 0)

# Khởi tạo mô hình
DT_model = DecisionTreeClassifier(max_depth=3)

# Lắp mô hình vào tập huấn luyện
DT_model.fit(X_train1, y_train1)

y_pred = DT_model.predict(X_test1)

print('Điểm chính xác của mô hình: {0:0.4f}'. format(accuracy_score(y_test1, y_pred)))

# in điểm trên tập huấn luyện và tập kiểm tra
print('Training set score: {:.4f}'.format(DT_model.score(X_train1, y_train1)))
print('Test set score: {:.4f}'.format(DT_model.score(X_test1, y_test1)))

kf = KFold(n_splits=10, shuffle=False)

score = cross_val_score(DT_model, X_train1, y_train1, cv=kf, scoring='accuracy')
DT_model_cv_score = score.mean()
DT_model_cv_stdev = stdev(score)
print('Cross Validation Accuracy scores are:\n {}'.format(score))

Accuracy  = ['Cross Validation Accuracy ']
DT_A = pd.DataFrame({'CV Mean':DT_model_cv_score,'Std':DT_model_cv_stdev},index=Accuracy )
DT_A

ConfusionMatrixDisplay.from_estimator(DT_model, X_test1, y_test1, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of Base Decision Tree')
plt.grid(False)

print(classification_report(y_test1, y_pred))

def metrics_calculator(y_test, y_pred, model_name):
    '''
    Hàm này tính toán tất cả các chỉ số hiệu suất mong muốn cho một mô hình nhất định.
    '''
    result = pd.DataFrame(data=[accuracy_score(y_test, y_pred),
                                precision_score(y_test, y_pred, average='macro'),
                                recall_score(y_test, y_pred, average='macro'),
                                f1_score(y_test, y_pred, average='macro')],
                          index=['Accuracy','Precision','Recall','F1-score'],
                          columns = [model_name])
    return result

BaseDT_result = metrics_calculator(y_test1, y_pred, 'Base Decision Tree')
BaseDT_result

from sklearn.preprocessing import label_binarize

y_Pred_prob = DT_model.predict_proba(X_test1)

def roc_curve_plot(y_actual, y_predicted_probs, figsize=(5, 4), title=None, legend_loc='best'):

  # Tính toán đường cong ROC và diện tích ROC cho mỗi lớp
    fpr = {}
    tpr = {}
    thres = {}
    roc_auc = {}

    n_class = y_predicted_probs.shape[1]
    for i in range(n_class):
        fpr[i], tpr[i], thres[i] = roc_curve(y_actual == i, y_predicted_probs[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    # Tạo một hình và vẽ đường cong ROC cho mỗi lớp
    plt.figure(figsize=figsize)
    for i in range(n_class):
        plt.plot(fpr[i], tpr[i], linewidth=1, label='Class {}: AUC={:.2f}'.format(i, roc_auc[i]))

   # Thêm nhãn đường chéo và trục
    plt.plot([0, 1], [0, 1], '--', linewidth=0.5)
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

    # Đặt giới hạn trục và thêm tiêu đề và chú giải
    plt.xlim([0, 1])
    plt.ylim([0, 1.05])
    if title is not None:
        plt.title(title)
    plt.legend(loc=legend_loc)

    # Hiển thị biểu đồ
    plt.show()
        
roc_curve_plot(y_test1, y_Pred_prob)

feature_names = X.columns
target_names = ["0", "1", "2", "3"]

fig = plt.figure(figsize = (20, 12))
Plot = tree.plot_tree (DT_model, feature_names = feature_names, class_names = target_names, filled = True)

# Tìm siêu tham số tối ưu (GridSearchCV)

# Xác định mô hình
model = DecisionTreeClassifier()

# Định nghĩa đánh giá
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=0)

# Xác định tham số tìm kiếm
max_depth = range(2, 19, 1)
criterion = ['entropy', 'gini']   

#min_samples_split = [2, 3, 4]
#min_samples_leaf = [1, 2, 3]

param_grid = {'max_depth': max_depth, 'criterion':criterion}

# Xác định tìm kiếm
search = GridSearchCV(model, param_grid, scoring='accuracy', n_jobs=-1, cv=cv)

# Thực hiện tìm kiếm
GridSearchCV = search.fit(X_train1, y_train1)

# Đặt clf thành tổ hợp tham số tốt nhất
DT_modelcv = GridSearchCV.best_estimator_

# Tóm tắt kết quả
print('Điểm cao nhất: %s' % GridSearchCV.best_score_)
print('Siêu tham số tốt nhất: %s' % GridSearchCV.best_params_)

DT_modelcv.fit(X_train1, y_train1)

print('Điểm chính xác của mô hình: {0:0.4f}'. format(accuracy_score(y_test1, y_pred)))

ConfusionMatrixDisplay.from_estimator(DT_modelcv, X_test1, y_test1, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of Tuned Decision Tree')
plt.grid(False)

print(classification_report(y_test1, y_pred))

TunedDT_result = metrics_calculator(y_test1, y_pred, 'Tuned Decision Tree')
TunedDT_result

y_Pred_prob = DT_modelcv.predict_proba(X_test1)

def roc_curve_plot(y_actual, y_predicted_probs, figsize=(5, 4), title=None, legend_loc='best'):

   # Tính toán đường cong ROC và diện tích ROC cho mỗi lớp
    fpr = {}
    tpr = {}
    thres = {}
    roc_auc = {}

    n_class = y_predicted_probs.shape[1]
    for i in range(n_class):
        fpr[i], tpr[i], thres[i] = roc_curve(y_actual == i, y_predicted_probs[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

   # Tạo một hình và vẽ đường cong ROC cho mỗi lớp
    plt.figure(figsize=figsize)
    for i in range(n_class):
        plt.plot(fpr[i], tpr[i], linewidth=1, label='Class {}: AUC={:.2f}'.format(i, roc_auc[i]))

   # Thêm nhãn đường chéo và trục
    plt.plot([0, 1], [0, 1], '--', linewidth=0.5)
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

    # Đặt giới hạn trục và thêm tiêu đề và chú giải
    plt.xlim([0, 1])
    plt.ylim([0, 1.05])
    if title is not None:
        plt.title(title)
    plt.legend(loc=legend_loc)

    # hiển thị biểu đồ
    plt.show()
        
roc_curve_plot(y_test1, y_Pred_prob)

feature_names = X.columns
target_names = ["0", "1", "2", "3"]

fig = plt.figure(figsize = (30, 15))
Plot = tree.plot_tree (DT_modelcv, feature_names = feature_names, class_names = target_names, filled = True)

X = df.drop('price_range', axis=1)
y = df['price_range'].ravel()

# Mảng giá trị kích thước thử nghiệm từ 0,2 đến 0,3
test_size = np.arange(start=0.2, stop=0.35, step=0.05)

# Khởi tạo danh sách nơi chúng tôi sẽ lưu trữ điểm của từng kích thước bài kiểm tra
score = []
for size in test_size:
    X_train3, X_test3, y_train3, y_test3 = train_test_split (X, y, test_size=size, random_state=0)
    svm_model = svm.SVC()
    svm_model.fit (X_train3, y_train3)
    score.append (svm_model.score (X_test3, y_test3))
    
# Tạo một khung dữ liệu để hiển thị kết quả 
r= pd.DataFrame({'Test size': test_size, 'Score': score})
r.sort_values(by = ['Score'], ascending = False, inplace = True)
r.style.highlight_max(color='purple')

# Tách X và y thành các tập huấn luyện và kiểm tra
X_train3, X_test3, y_train3, y_test3 = train_test_split (X, y, stratify=y, test_size = 0.3 , random_state = 0)

# Chia tỷ lệ các tính năng bằng StandardScaler
scaler = StandardScaler()

# Khớp bộ chia tỷ lệ với dữ liệu đào tạo và biến đổi nó
X_train3 = scaler.fit_transform(X_train3)

# Chuyển đổi dữ liệu thử nghiệm bằng cùng một bộ chia tỷ lệ
X_test3 = scaler.transform(X_test3)

# Khởi tạo mô hình
svm_model = svm.SVC(probability=True)

# Lắp mô hình vào tập huấn luyện
svm_model.fit(X_train3, y_train3)

y_pred = svm_model.predict(X_test3)

print('Điểm chính xác của mô hình: {0:0.4f}'. format(accuracy_score(y_test3, y_pred)))

# Điểm trên training and test set
print('Training set score: {:.4f}'.format(svm_model.score(X_train3, y_train3)))
print('Test set score: {:.4f}'.format(svm_model.score(X_test3, y_test3)))

kf = KFold(n_splits=10, shuffle=False)

score = cross_val_score(svm_model, X_train3, y_train3, cv=kf, scoring='accuracy')
svm_model_cv_score = score.mean()
svm_model_cv_stdev = stdev(score)
print('Cross Validation Accuracy scores are:\n {}'.format(score))

Accuracy = ['Cross Validation Accuracy']
svm_A = pd.DataFrame({'CV Mean':svm_model_cv_score,'Std':svm_model_cv_stdev},index=Accuracy)
svm_A

ConfusionMatrixDisplay.from_estimator(svm_model, X_test3, y_test3, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of Base SVM')
plt.grid(False)

print(classification_report(y_test3, y_pred))

BaseSVM_result = metrics_calculator(y_test3, y_pred, 'Base SVM')
BaseSVM_result

y_Pred_prob = svm_model.predict_proba(X_test3)

def roc_curve_plot(y_actual, y_predicted_probs, figsize=(5, 4), title=None, legend_loc='best'):

   # Tính toán đường cong ROC và diện tích ROC cho mỗi lớp
    fpr = {}
    tpr = {}
    thres = {}
    roc_auc = {}

    n_class = y_predicted_probs.shape[1]
    for i in range(n_class):
        fpr[i], tpr[i], thres[i] = roc_curve(y_actual == i, y_predicted_probs[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    # Tạo một hình và vẽ đường cong ROC cho mỗi lớp
    plt.figure(figsize=figsize)
    for i in range(n_class):
        plt.plot(fpr[i], tpr[i], linewidth=1, label='Class {}: AUC={:.2f}'.format(i, roc_auc[i]))

    # Thêm nhãn đường chéo và trục
    plt.plot([0, 1], [0, 1], '--', linewidth=0.5)
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

    # Đặt giới hạn trục và thêm tiêu đề và chú giải
    plt.xlim([0, 1])
    plt.ylim([0, 1.05])
    if title is not None:
        plt.title(title)
    plt.legend(loc=legend_loc)

    # Hiển thị biểu đồ
    plt.show()
        
roc_curve_plot(y_test3, y_Pred_prob)

# Tìm siêu tham số tối ưu (GridSearchCV)
from sklearn.model_selection import GridSearchCV

# Xác định mô hình
model = svm.SVC(probability=True)

# Định nghĩa đánh giá
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=0)

# Xác định tham số tìm kiếm  
C = [0.1, 1, 10, 100]
kernel = ['linear', 'poly', 'rbf', 'sigmoid']
gamma = ['scale', 'auto']

#degree = [2, 3, 4]
#coef0 = [0, 1, 2]

param_grid = {'C': C, 'kernel': kernel, 'gamma': gamma} 

# Xác định tìm kiếm
search = GridSearchCV(model, param_grid, scoring='accuracy', n_jobs=-1, cv=cv)
# Thực hiện tìm kiếm
GridSearchCV = search.fit(X_train3, y_train3)
# Đặt clf thành tổ hợp tham số tốt nhất
svm_modelcv = GridSearchCV.best_estimator_

# Tóm tắt kết quả
print('Điểm cao nhất: %s' % GridSearchCV.best_score_)
print('Siêu tham số tốt nhất: %s' % GridSearchCV.best_params_)

svm_modelcv.fit(X_train3, y_train3)

y_pred = svm_modelcv.predict(X_test3)

print('Điểm chính xác của mô hình: {0:0.4f}'. format(accuracy_score(y_test3, y_pred)))

ConfusionMatrixDisplay.from_estimator(svm_modelcv, X_test3, y_test3, colorbar=False, cmap='Greens')
plt.title('Confusion Matrix of Tuned SVM')
plt.grid(False)

print(classification_report(y_test3, y_pred))

TunedSVM_result = metrics_calculator(y_test3, y_pred, 'Tuned SVM')
TunedSVM_result

y_Pred_prob = svm_modelcv.predict_proba(X_test3)

def roc_curve_plot(y_actual, y_predicted_probs, figsize=(5, 4), title=None, legend_loc='best'):

    # Tính toán đường cong ROC và diện tích ROC cho mỗi lớp
    fpr = {}
    tpr = {}
    thres = {}
    roc_auc = {}

    n_class = y_predicted_probs.shape[1]
    for i in range(n_class):
        fpr[i], tpr[i], thres[i] = roc_curve(y_actual == i, y_predicted_probs[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    # Tạo một hình và vẽ đường cong ROC cho mỗi lớp
    plt.figure(figsize=figsize)
    for i in range(n_class):
        plt.plot(fpr[i], tpr[i], linewidth=1, label='Class {}: AUC={:.2f}'.format(i, roc_auc[i]))

    # Thêm nhãn đường chéo và trục
    plt.plot([0, 1], [0, 1], '--', linewidth=0.5)
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

    # Đặt giới hạn trục và thêm tiêu đề và chú giải
    plt.xlim([0, 1])
    plt.ylim([0, 1.05])
    if title is not None:
        plt.title(title)
    plt.legend(loc=legend_loc)

    # Hiển thị biểu đồ
    plt.show()
        
roc_curve_plot(y_test3, y_Pred_prob)

Conclusion = pd.concat([BaseDT_result, TunedDT_result, BaseSVM_result, TunedSVM_result], axis=1)
Conclusion

# Tạo các ô con có 2 hàng và 4 cột
fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(16,8))

# Biểu đồ confusion matrix cho Base Decision Tree
ax = axs[0, 0]
disp = ConfusionMatrixDisplay.from_estimator(DT_model, X_test1, y_test1, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Base Decision Tree')
disp.ax_.grid(False)

# Biểu đồ confusion matrix cho Tuned Decision Tree
ax = axs[0, 1]
disp = ConfusionMatrixDisplay.from_estimator(DT_modelcv, X_test1, y_test1, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Tuned Decision Tree')
disp.ax_.grid(False)



# Biểu đồ confusion matrix cho Base SVM
ax = axs[1, 0]
disp = ConfusionMatrixDisplay.from_estimator(svm_model, X_test3, y_test3, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Base SVM')
disp.ax_.grid(False)

# Biểu đồ confusion matrix cho Tuned SVM
ax = axs[1, 1]
disp = ConfusionMatrixDisplay.from_estimator(svm_modelcv, X_test3, y_test3, colorbar=False, cmap='Greens', ax=ax)
disp.ax_.set_title('Confusion Matrix of Tuned SVM')
disp.ax_.grid(False)



# Điều chỉnh khoảng cách giữa các ô con
plt.subplots_adjust(hspace=0.4, wspace=0.3)

plt.show()

Df_test.head()

# gán tên cột của DataFrame ban đầu cho biến cols
cols = Df_test.columns

# tạo một phiên bản của StandardScaler
scaler_test = StandardScaler()

# điều chỉnh tỷ lệ phù hợp với test data và biến đổi nó
scaled_test = scaler_test.fit_transform(Df_test)

# tạo DataFrame từ các tính năng được chia tỷ lệ của test dataset
scaled_test = pd.DataFrame(scaled_test, columns=[cols])

scaled_test.head()

# Dự đoán Phạm vi giá dựa trên Tuned SVM Model Mô hình tốt nhất
predicted_price_range = svm_modelcv.predict(scaled_test)

#Tạo một khung dữ liệu mới cho dự đoán price range
predicted_df = pd.DataFrame({'predicted_price_range': predicted_price_range})
predicted_df

new_samples = Df_test.copy()

# Thêm phạm vi giá dự đoán vào new_samples DataFrame
new_samples['pred_price_range'] = predicted_price_range
new_samples.head(10).style.set_properties(**{'background-color': 'Orange'}, subset=['pred_price_range'])

# Ánh xạ các giá trị phạm vi giá thành tên
price_range_map = {
    0: 'Low Cost',
    1: 'Medium Cost',
    2: 'High Cost',
    3: 'Very High Cost',
}

# Thêm cột mới với phạm vi giá được ánh xạ
new_samples['pred_price_range_name'] = new_samples['pred_price_range'].map(price_range_map)

# Hiển thị khung dữ liệu được cập nhật
new_samples.tail(10).style.set_properties(**{'background-color': 'Orange'}, subset=['pred_price_range_name'])

